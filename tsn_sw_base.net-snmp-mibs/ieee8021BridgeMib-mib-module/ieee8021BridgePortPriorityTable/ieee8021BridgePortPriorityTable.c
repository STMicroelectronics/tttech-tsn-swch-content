/*
 * TTTech ieee8021BridgeMib-mib-module
 * Copyright(c) 2019 TTTech Industrial Automation AG.
 *
 * ALL RIGHTS RESERVED.
 * Usage of this software, including source code, netlists, documentation,
 * is subject to restrictions and conditions of the applicable license
 * agreement with TTTech Industrial Automation AG or its affiliates.
 *
 * All trademarks used are the property of their respective owners.
 *
 * TTTech Industrial Automation AG and its affiliates do not assume any liability
 * arising out of the application or use of any product described or shown
 * herein. TTTech Industrial Automation AG and its affiliates reserve the right to
 * make changes, at any time, in order to improve reliability, function or
 * design.
 *
 * Contact Information:
 * support@tttech-industrial.com
 * TTTech Industrial Automation AG, Schoenbrunnerstrasse 7, 1040 Vienna, Austria
 */
/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
/* module specific */
#include "ieee8021BridgePortPriorityTable.h"
#include "../ieee8021BridgeMib_helpers/ieee8021BridgeMib_helpers.h"
/* libbase includes */
#include "base_prints.h"
#include "base_linux_tool_helpers.h"
#include "base_q_bridge_linux_tools.h"
#include "base_private_translators.h"
/* libtsn includes */
#include "tsn.h"
#include "tsn_bridge.h"

/** Initializes the ieee8021BridgePortPriorityTable module */
void
init_ieee8021BridgePortPriorityTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_ieee8021BridgePortPriorityTable();
}

/** Initialize the ieee8021BridgePortPriorityTable table by defining its contents and how it's structured */
void
initialize_table_ieee8021BridgePortPriorityTable(void)
{
    const oid ieee8021BridgePortPriorityTable_oid[] = {1,3,111,2,802,1,1,2,1,3,1};
    const size_t ieee8021BridgePortPriorityTable_oid_len   = OID_LENGTH(ieee8021BridgePortPriorityTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_tdata                   *table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache                   *cache;

//    DEBUGMSGTL(("ieee8021BridgePortPriorityTable:init", "initializing table ieee8021BridgePortPriorityTable\n"));

    reg = netsnmp_create_handler_registration(
              "ieee8021BridgePortPriorityTable",     ieee8021BridgePortPriorityTable_handler,
              ieee8021BridgePortPriorityTable_oid, ieee8021BridgePortPriorityTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_data = netsnmp_tdata_create_table( "ieee8021BridgePortPriorityTable", 0 );
    if (NULL == table_data) {
        snmp_log(LOG_ERR,"error creating tdata table for ieee8021BridgePortPriorityTable\n");
        return;
    }
    cache = netsnmp_cache_create(IEEE8021BRIDGEPORTPRIORITYTABLE_TIMEOUT,
                                  ieee8021BridgePortPriorityTable_load, ieee8021BridgePortPriorityTable_free,
                                  ieee8021BridgePortPriorityTable_oid, ieee8021BridgePortPriorityTable_oid_len);
    if (NULL == cache) {
        snmp_log(LOG_ERR,"error creating cache for ieee8021BridgePortPriorityTable\n");
    }
    else
    {
        cache->magic = (void *)table_data;
        cache->flags =  NETSNMP_CACHE_DONT_FREE_EXPIRED     | \
                        NETSNMP_CACHE_DONT_AUTO_RELEASE     | \
                        NETSNMP_CACHE_AUTO_RELOAD           | \
                        NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | \
                        NETSNMP_CACHE_DONT_INVALIDATE_ON_SET ;
    }

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    if (NULL == table_info) {
        snmp_log(LOG_ERR,"error creating table info for ieee8021BridgePortPriorityTable\n");
        return;
    }
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_UNSIGNED,  /* index: ieee8021BridgeBasePortComponentId */
                           ASN_UNSIGNED,  /* index: ieee8021BridgeBasePort */
                           0);

    table_info->min_column = COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY;
    table_info->max_column = COLUMN_IEEE8021BRIDGEPORTSERVICEACCESSPRIORITYSELECTION;
    
    netsnmp_tdata_register( reg, table_data, table_info );
    /* Initialise the contents of the table here */
    if(0 != init_ieee8021BridgePortPriorityTable_with_sys_data(table_data))
    {
        snmp_log(LOG_ERR,"ERROR: ieee8021BridgePortPriorityTable initialization was unsuccessful.\n");
        free(table_info);
        return;
    }
    else
    {
        snmp_log(LOG_INFO,"INFO: ieee8021BridgePortPriorityTable initialization was successful.\n");
        netsnmp_cache_timer_start(cache);
    }
}

/* init table */
int init_ieee8021BridgePortPriorityTable_with_sys_data(netsnmp_tdata *table_data)
{
    netsnmp_tdata_row *row = NULL;
    char ports_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN];
    int i = 0;
	struct port_hdl *port = NULL;
	uint32_t port_id = 0u;

    snmp_log(LOG_INFO,"called: init_ieee8021BridgePortPriorityTable_with_sys_data.\n");

    /* gather system data */
    if(EXIT_FAILURE == get_bridge_port_names(ports_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN))
    {
    	snmp_log(LOG_ERR, "ERROR: get_bridge_port_names failed.\n");
        return 1;
    }

    while((i < MAX_NUM_OF_INTERFACES) && (0 != strncmp(ports_name[i], "", MAX_STR_LEN)))
    {
    	port = tsn_port_open_by_name(ports_name[i]);//open port with port_name
    	if(NULL != port)
    	{
    	    if(0 != tsn_bridge_port_id(port, &port_id))//read port_id
    	    {
				snmp_log(LOG_ERR, "ERROR: Failed to get port id: '%s'.\n", ports_name[i]);
				tsn_port_close(port);
				break;
			}
        	snmp_log(LOG_ERR, "%s(): ports_name[%d] = %s, port_id + 1 = %lu\n", __func__, i, ports_name[i], (u_long)(port_id + 1));
    	    tsn_port_close(port);
    	}
    	else//port could not be open
    	{
            snmp_log(LOG_ERR, "%s(): port could not open: (%s)\n", __func__, ports_name[i]);
            break;
    	}

		row = ieee8021BridgePortPriorityTable_createEntry(table_data, 1, port_id + 1);
		if(NULL != row)
		{
			ieee8021BridgePortPriorityTable_fillEntry(ports_name[i], (ieee8021BridgePortPriorityTable_entry_t*)row->data);
		}
		else
		{
			snmp_log(LOG_ERR, "ERROR: New row is not created.\n");
			tsn_port_close(port);
			break;
		}
    	row = NULL;
    	i++;
    }

    return 0;
}

/* create a new row in the table */
netsnmp_tdata_row *
ieee8021BridgePortPriorityTable_createEntry(netsnmp_tdata *table_data
                 , u_long  ieee8021BridgeBasePortComponentId
                 , u_long  ieee8021BridgeBasePort
                ) {
    struct ieee8021BridgePortPriorityTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct ieee8021BridgePortPriorityTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;

//    DEBUGMSGT(("ieee8021BridgePortPriorityTable:entry:create", "row 0x%x\n", (uintptr_t)row));
    snmp_log(LOG_INFO,"ieee8021BridgePortPriorityTable_createEntry - (%ld) - (%ld)\n",
    		ieee8021BridgeBasePortComponentId, ieee8021BridgeBasePort);

    entry->ieee8021BridgeBasePortComponentId = ieee8021BridgeBasePortComponentId;
    netsnmp_tdata_row_add_index( row, ASN_UNSIGNED,
                                 &(entry->ieee8021BridgeBasePortComponentId),
                                 sizeof(entry->ieee8021BridgeBasePortComponentId));
    entry->ieee8021BridgeBasePort = ieee8021BridgeBasePort;
    netsnmp_tdata_row_add_index( row, ASN_UNSIGNED,
                                 &(entry->ieee8021BridgeBasePort),
                                 sizeof(entry->ieee8021BridgeBasePort));
    if (table_data)
        netsnmp_tdata_add_row( table_data, row );
    return row;
}

/* fill a new row data in the table */
int ieee8021BridgePortPriorityTable_fillEntry(char port_name[MAX_STR_LEN],
		ieee8021BridgePortPriorityTable_entry_t *entry)
{
	struct port_hdl *port = NULL;
	uint32_t tmp_ui32 = 0u;

	snmp_log(LOG_DEBUG, "called: ieee8021BridgePortPriorityTable_fillEntry for port: '%s'\n", port_name);

    if (!entry)
    {
        snmp_log(LOG_ERR, "ieee8021BridgePortPriorityTable_fillEntry:entry == NULL\n");
        /* error */
        return 1;
    }

	port = tsn_port_open_by_name(port_name);
	if(NULL == port)
	{
        snmp_log(LOG_ERR, "port could not open\n");
        /* error */
        return 1;
	}

    if(0 == tsn_bridge_get_default_prio(port, &tmp_ui32))
    {
    	entry->ieee8021BridgePortDefaultUserPriority = (u_long)tmp_ui32;
    }

    if(0 == tsn_bridge_get_num_traffic_classes(port, &tmp_ui32))
    {
    	entry->ieee8021BridgePortNumTrafficClasses = (u_long)tmp_ui32;
    }

    tsn_port_close(port);
    return 0;
}

/* remove a row from the table */
void
ieee8021BridgePortPriorityTable_removeEntry(netsnmp_tdata     *table_data, 
                 netsnmp_tdata_row *row) {
    struct ieee8021BridgePortPriorityTable_entry *entry;

    if (!row)
        return;    /* Nothing to remove */

//    DEBUGMSGT(("ieee8021BridgePortPriorityTable:entry:remove", "row 0x%x\n", (uintptr_t)row));
    entry = (struct ieee8021BridgePortPriorityTable_entry *)row->data;
    SNMP_FREE( entry );   /* XXX - release any other internal resources */

    if (table_data)
        netsnmp_tdata_remove_and_delete_row( table_data, row );
    else
        netsnmp_tdata_delete_row( row );    
}

/* Example cache handling - set up table_data list from a suitable file */
int
ieee8021BridgePortPriorityTable_load( netsnmp_cache *cache, void *vmagic ) {
    /* will be used to iterate trough ieee8021BridgeBaseTable_head */
	netsnmp_tdata_row *agent_row = NULL;
	/* helper to keep next agent row */
	netsnmp_tdata_row *next_agent_row = NULL;
	/* will be used to check existence of the bridge */
	netsnmp_tdata *table = (netsnmp_tdata *)vmagic;
	ieee8021BridgePortPriorityTable_entry_t *entry = NULL;
	int port_found = 0;
	char ports_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN];
	u_long component_id = 1;
	struct port_hdl *port = NULL;
	uint32_t port_id = 0u;
	int i = 0;
	char port_name[MAX_STR_LEN];

	snmp_log(LOG_DEBUG, "called: ieee8021BridgePortPriorityTable_load\n");

	/* gather fresh system data */
	if(EXIT_FAILURE == get_bridge_port_names(ports_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN))
	{
		snmp_log(LOG_ERR, "ERROR: get_bridge_port_names failed.\n");
		return 1;
	}

	/* returns the first row in the table */
	agent_row = netsnmp_tdata_row_first (table);

	while(NULL != agent_row)
	{
		entry = (ieee8021BridgePortPriorityTable_entry_t*)agent_row->data;

		if(NULL != entry)
		{
			/* there is no more agent_row, erase it from agent */
			if(!entry->ieee8021BridgeBasePortComponentId || !entry->ieee8021BridgeBasePort)
			{
				snmp_log(LOG_DEBUG, "there is no more agent_row, erase it from agent\n");
				/* returns next row */
				next_agent_row = netsnmp_tdata_row_next (table, agent_row);
				ieee8021BridgePortPriorityTable_removeEntry(table, agent_row);
				agent_row = next_agent_row;
				next_agent_row = NULL;
			}
			/* agent_row exist on system, skip it (leave it on agent) */
			else
			{
				snmp_log(LOG_DEBUG, "agent_row exist on system, skip it\n");
				/* refresh data in this existing row on agent */
				if(EXIT_FAILURE == get_port_name_by_tsn_port_id(entry->ieee8021BridgeBasePort, port_name))
				{
					snmp_log(LOG_ERR, "error: get_port_name_by_tsn_port_id returns EXIT_FAILURE\n");
					return 1;
				}
				if(NULL != port_name)
				{
					ieee8021BridgePortPriorityTable_fillEntry(port_name,
							(ieee8021BridgePortPriorityTable_entry_t *)agent_row->data);
				}
				/* take next */
				agent_row = netsnmp_tdata_row_next (table, agent_row);
			}
		}
		else
		{
			snmp_log(LOG_ERR, "error: agent_row->data is NULL\n");
		}
	}

	i = 0;
	while((i < MAX_NUM_OF_INTERFACES) && (0 != strncmp(ports_name[i], "", MAX_STR_LEN)))
	{
		snmp_log(LOG_DEBUG, "load: looking for port: %s\n", ports_name[i]);
		port = tsn_port_open_by_name(ports_name[i]);
		if(NULL == port)
		{
			snmp_log(LOG_ERR, "port could not open: '%s'\n", ports_name[i]);
			/* error */
			break;
		}
		if(0 != tsn_bridge_port_id(port, &port_id))
		{
			snmp_log(LOG_ERR, "could not get port id: '%s'\n", ports_name[i]);
			tsn_port_close(port);
			/* error */
			break;
		}
		tsn_port_close(port);
		/* returns the first row in the table */
		agent_row = netsnmp_tdata_row_first (table);

		while((NULL != agent_row) && (port_found == 0))
		{
			entry = (ieee8021BridgePortPriorityTable_entry_t *)agent_row->data;

			if( (entry->ieee8021BridgeBasePortComponentId == component_id) &&
					(entry->ieee8021BridgeBasePort == (port_id + 1)) )
			{
				port_found = 1;
			}

			agent_row = netsnmp_tdata_row_next (table, agent_row);
		}
		if(port_found == 0)
		{
			snmp_log(LOG_DEBUG, "load: Adding new port: %s\n", ports_name[i]);
			agent_row = ieee8021BridgePortPriorityTable_createEntry(table, component_id, port_id + 1);
			ieee8021BridgePortPriorityTable_fillEntry(ports_name[i], agent_row->data);
		}
		i++;
		port_found = 0;
	}

    return 0;  /* OK */
}

void
ieee8021BridgePortPriorityTable_free( netsnmp_cache *cache, void *vmagic ) {
    netsnmp_tdata     *table = (netsnmp_tdata *)vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_row_first(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the ieee8021BridgePortPriorityTable table */
int
ieee8021BridgePortPriorityTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata              *table_data;
    netsnmp_tdata_row          *table_row;
    struct ieee8021BridgePortPriorityTable_entry          *table_entry;
    int                         ret;
    char port_name[MAX_STR_LEN];
    struct port_hdl *port = NULL;

//    DEBUGMSGTL(("ieee8021BridgePortPriorityTable:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021BridgePortPriorityTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_UNSIGNED,
                                            table_entry->ieee8021BridgePortDefaultUserPriority);
                break;
            case COLUMN_IEEE8021BRIDGEPORTNUMTRAFFICCLASSES:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021BridgePortNumTrafficClasses);
                break;
#if 0
            case COLUMN_IEEE8021BRIDGEPORTPRIORITYCODEPOINTSELECTION:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021BridgePortPriorityCodePointSelection);
                break;
            case COLUMN_IEEE8021BRIDGEPORTUSEDEI:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021BridgePortUseDEI);
                break;
            case COLUMN_IEEE8021BRIDGEPORTREQUIREDROPENCODING:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021BridgePortRequireDropEncoding);
                break;
            case COLUMN_IEEE8021BRIDGEPORTSERVICEACCESSPRIORITYSELECTION:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021BridgePortServiceAccessPrioritySelection);
                break;
#endif
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;
#if 0
            table_entry = (struct ieee8021BridgePortPriorityTable_entry *)
                              netsnmp_tdata_extract_entry(request);
#endif
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
#if 0
            case COLUMN_IEEE8021BRIDGEPORTNUMTRAFFICCLASSES:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021BRIDGEPORTPRIORITYCODEPOINTSELECTION:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021BRIDGEPORTUSEDEI:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021BRIDGEPORTREQUIREDROPENCODING:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021BRIDGEPORTSERVICEACCESSPRIORITYSELECTION:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
#endif
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021BridgePortPriorityTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY:
                table_entry->old_ieee8021BridgePortDefaultUserPriority = table_entry->ieee8021BridgePortDefaultUserPriority;
                table_entry->ieee8021BridgePortDefaultUserPriority     = *request->requestvb->val.integer;

				if(EXIT_FAILURE == get_port_name_by_tsn_port_id(table_entry->ieee8021BridgeBasePort, port_name))
				{
					snmp_log(LOG_ERR, "error: get_port_name_by_tsn_port_id returns EXIT_FAILURE\n");
					break;
				}
				port = tsn_port_open_by_name(port_name);
				if(NULL == port)
				{
					snmp_log(LOG_ERR, "port could not open\n");
					/* error */
					break;
				}
			    if(0 != tsn_bridge_set_default_prio(port, table_entry->ieee8021BridgePortDefaultUserPriority))
			    {
					snmp_log(LOG_ERR, "tsn_bridge_set_default_prio FAILED!\n");
					/* error */
					break;
			    }
			    tsn_port_close(port);

                break;
#if 0
            case COLUMN_IEEE8021BRIDGEPORTNUMTRAFFICCLASSES:
                table_entry->old_ieee8021BridgePortNumTrafficClasses = table_entry->ieee8021BridgePortNumTrafficClasses;
                table_entry->ieee8021BridgePortNumTrafficClasses     = *request->requestvb->val.integer;
                break;
            case COLUMN_IEEE8021BRIDGEPORTPRIORITYCODEPOINTSELECTION:
                table_entry->old_ieee8021BridgePortPriorityCodePointSelection = table_entry->ieee8021BridgePortPriorityCodePointSelection;
                table_entry->ieee8021BridgePortPriorityCodePointSelection     = *request->requestvb->val.integer;
                break;
            case COLUMN_IEEE8021BRIDGEPORTUSEDEI:
                table_entry->old_ieee8021BridgePortUseDEI = table_entry->ieee8021BridgePortUseDEI;
                table_entry->ieee8021BridgePortUseDEI     = *request->requestvb->val.integer;
                break;
            case COLUMN_IEEE8021BRIDGEPORTREQUIREDROPENCODING:
                table_entry->old_ieee8021BridgePortRequireDropEncoding = table_entry->ieee8021BridgePortRequireDropEncoding;
                table_entry->ieee8021BridgePortRequireDropEncoding     = *request->requestvb->val.integer;
                break;
            case COLUMN_IEEE8021BRIDGEPORTSERVICEACCESSPRIORITYSELECTION:
                table_entry->old_ieee8021BridgePortServiceAccessPrioritySelection = table_entry->ieee8021BridgePortServiceAccessPrioritySelection;
                table_entry->ieee8021BridgePortServiceAccessPrioritySelection     = *request->requestvb->val.integer;
                break;
#endif
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021BridgePortPriorityTable_entry *)
                              netsnmp_tdata_extract_entry(request);
#if 0
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
#endif
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY:
                table_entry->ieee8021BridgePortDefaultUserPriority     = table_entry->old_ieee8021BridgePortDefaultUserPriority;
                table_entry->old_ieee8021BridgePortDefaultUserPriority = 0;
                break;
#if 0
            case COLUMN_IEEE8021BRIDGEPORTNUMTRAFFICCLASSES:
                table_entry->ieee8021BridgePortNumTrafficClasses     = table_entry->old_ieee8021BridgePortNumTrafficClasses;
                table_entry->old_ieee8021BridgePortNumTrafficClasses = 0;
                break;
            case COLUMN_IEEE8021BRIDGEPORTPRIORITYCODEPOINTSELECTION:
                table_entry->ieee8021BridgePortPriorityCodePointSelection     = table_entry->old_ieee8021BridgePortPriorityCodePointSelection;
                table_entry->old_ieee8021BridgePortPriorityCodePointSelection = 0;
                break;
            case COLUMN_IEEE8021BRIDGEPORTUSEDEI:
                table_entry->ieee8021BridgePortUseDEI     = table_entry->old_ieee8021BridgePortUseDEI;
                table_entry->old_ieee8021BridgePortUseDEI = 0;
                break;
            case COLUMN_IEEE8021BRIDGEPORTREQUIREDROPENCODING:
                table_entry->ieee8021BridgePortRequireDropEncoding     = table_entry->old_ieee8021BridgePortRequireDropEncoding;
                table_entry->old_ieee8021BridgePortRequireDropEncoding = 0;
                break;
            case COLUMN_IEEE8021BRIDGEPORTSERVICEACCESSPRIORITYSELECTION:
                table_entry->ieee8021BridgePortServiceAccessPrioritySelection     = table_entry->old_ieee8021BridgePortServiceAccessPrioritySelection;
                table_entry->old_ieee8021BridgePortServiceAccessPrioritySelection = 0;
                break;
#endif
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
