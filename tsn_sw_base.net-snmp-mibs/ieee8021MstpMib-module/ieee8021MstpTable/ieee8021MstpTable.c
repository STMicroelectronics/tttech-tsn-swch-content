/*
 * TTTech ieee8021MstpMib-mib-module
 * Copyright(c) 2019 TTTech Computertechnik AG.
 *
 * ALL RIGHTS RESERVED.
 * Usage of this software, including source code, netlists, documentation,
 * is subject to restrictions and conditions of the applicable license
 * agreement with TTTech Computertechnik AG or its affiliates.
 *
 * All trademarks used are the property of their respective owners.
 *
 * TTTech Computertechnik AG and its affiliates do not assume any liability
 * arising out of the application or use of any product described or shown
 * herein. TTTech Computertechnik AG and its affiliates reserve the right to
 * make changes, at any time, in order to improve reliability, function or
 * design.
 *
 * Contact Information:
 * support@4me.tttech-dependablenetworks.com
 * TTTech Computertechnik AG, Schoenbrunnerstrasse 7, 1040 Vienna, Austria
 */
/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include "ieee8021MstpTable.h"
/* libbase includes */
#include "base_prints.h"
#include "base_mstp_linux_tools.h"

/* global variable */
u_long bridge_id = 1;// only one bridge is supported, hard coded

/** Initializes the ieee8021MstpTable module */
void init_ieee8021MstpTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_ieee8021MstpTable();
}


/** Initialize the ieee8021MstpTable table by defining its contents and how it's structured */
void
initialize_table_ieee8021MstpTable(void)
{
    const oid ieee8021MstpTable_oid[] = {1,3,111,2,802,1,1,6,1,2};
    const size_t ieee8021MstpTable_oid_len   = OID_LENGTH(ieee8021MstpTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_tdata                   *table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache                   *cache;

    DEBUGMSGTL(("ieee8021MstpTable:init", "initializing table ieee8021MstpTable\n"));

    reg = netsnmp_create_handler_registration(
              "ieee8021MstpTable",     ieee8021MstpTable_handler,
              ieee8021MstpTable_oid, ieee8021MstpTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_data = netsnmp_tdata_create_table( "ieee8021MstpTable", 0 );
    if (NULL == table_data) {
        snmp_log(LOG_ERR,"error creating tdata table for ieee8021MstpTable\n");
        return;
    }
    cache = netsnmp_cache_create(IEEE8021MSTPTABLE_TIMEOUT,
                                  ieee8021MstpTable_load, ieee8021MstpTable_free,
                                  ieee8021MstpTable_oid, ieee8021MstpTable_oid_len);
    if (NULL == cache) {
        snmp_log(LOG_ERR,"error creating cache for ieee8021MstpTable\n");
    }
    else
    {
        cache->magic = (void *)table_data;
		cache->flags =  NETSNMP_CACHE_DONT_FREE_EXPIRED     | \
						NETSNMP_CACHE_DONT_AUTO_RELEASE     | \
						NETSNMP_CACHE_AUTO_RELOAD           | \
						NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | \
						NETSNMP_CACHE_DONT_INVALIDATE_ON_SET ;
	}
    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    if (NULL == table_info) {
        snmp_log(LOG_ERR,"error creating table info for ieee8021MstpTable\n");
        return;
    }
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_UNSIGNED,  /* index: ieee8021MstpComponentId */
                           ASN_UNSIGNED,  /* index: ieee8021MstpId */
                           0);

    table_info->min_column = COLUMN_IEEE8021MSTPBRIDGEID;
    table_info->max_column = COLUMN_IEEE8021MSTPROWSTATUS;
    
    netsnmp_tdata_register( reg, table_data, table_info );

    /* Initialise the contents of the table here */
    if(0 != init_ieee8021MstpTable_with_sys_data(table_data))
    {
        snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Table Init was unsuccessful");
        free(table_info);
        return;
    }
    else
    {
        snmp_log(LOG_INFO, SNMP_MSG_FUN_AND_MSG, __func__, "Table Init was successful");
        netsnmp_cache_timer_start(cache);
    }
}

/* init table */
int init_ieee8021MstpTable_with_sys_data(netsnmp_tdata *table_data)
{
    netsnmp_tdata_row *row = NULL;
    int i = 0;
    int ret = 0;//success
    u_long  tmp_ieee8021MstpId = 0;
    char bridges_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
    char mstp_ids[BASE_MAX_VID][BASE_TEN] = {0};

    do{
		/* gather system data */
		if(EXIT_FAILURE == get_mstp_bridge_names(bridges_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN))
		{
			snmp_log(LOG_ERR, "ERROR: %s(): Internal error. Bridges' names are unreachable.\n", __func__);
			ret = 1;
			break;
		}
		// remove module from server if system supports more than one bridge
		if(0 != strncmp(bridges_name[1], "", MAX_STR_LEN))
		{
			snmp_log(LOG_ERR, "ERROR: %s(): Internal error. Bridges' names are unreachable.\n", __func__);
			ret = 1;
			break;
		}
		if(0 != strncmp(bridges_name[0], "", MAX_STR_LEN))
		{
			if (EXIT_FAILURE == get_bridge_mstpi(mstp_ids, BASE_MAX_VID, BASE_TEN, bridges_name[0]))//only one bridge is supported
			{
				snmp_log(LOG_ERR, "ERROR: %s(): Internal error. Bridge mstpi ids are unreachable.\n", __func__);
				ret = 1;
				break;
			}
		}
		while((i < BASE_MAX_VID) && (0 != strncmp(mstp_ids[i], "", BASE_TEN)))
		{
			tmp_ieee8021MstpId = strtoul(mstp_ids[i], NULL, 10);
			row = ieee8021MstpTable_createEntry(table_data, bridge_id, tmp_ieee8021MstpId);
			if(NULL != row)
			{
				if(0 != ieee8021MstpTable_fillEntry(bridges_name[0], bridge_id, tmp_ieee8021MstpId, (ieee8021MstpTable_entry_t*)row->data))
				{
					snmp_log(LOG_ERR, "ERROR: %s(): New row is not filled.\n", __func__);
					ret = 1;/* error */
					break;
				}
			}
			else
			{
				snmp_log(LOG_ERR, "ERROR: %s(): New row is not created.\n", __func__);
				ret = 1;/* error */
				break;
			}
			row = NULL;
			i++;
		}
	}while(0);

    return ret;
}

/* fill a new row data in the table */
int ieee8021MstpTable_fillEntry( char bridge_name[MAX_STR_LEN]
		                       , u_long bridge_id
							   , u_long mstp_id
							   , ieee8021MstpTable_entry_t *entry
							   )
{
    char result_array[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
    char tmp_mstp_id[BASE_FIVE] = {0};
    int ret = 0; //success

    snmp_log(LOG_DEBUG, "%s(): is called.\n", __func__);

    snprintf(tmp_mstp_id, BASE_FIVE, "%lu", mstp_id);
    do{
		if (!entry)
		{
			snmp_log(LOG_ERR, "%s(): entry == NULL\n", __func__);
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpEntry, leaf ieee8021MstpBridgeId */
		if(EXIT_SUCCESS == get_mstp_bridge_id(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, tmp_mstp_id))
		{
			strncpy(entry->ieee8021MstpBridgeId, result_array[0], MAX_STR_LEN);
			entry->ieee8021MstpBridgeId_len = strlen(entry->ieee8021MstpBridgeId);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpEntry, ieee8021MstpTimeSinceTopologyChange */
		if(EXIT_SUCCESS == get_mstp_time_since_top_change(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, tmp_mstp_id))
		{
			entry->ieee8021MstpTimeSinceTopologyChange = strtoul(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpEntry, leaf ieee8021MstpTopologyChanges */
		if(EXIT_SUCCESS == get_mstp_top_changes(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, tmp_mstp_id))
		{
			entry->ieee8021MstpTopologyChanges = strtoul(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpEntry, leaf ieee8021MstpDesignatedRoot */
		if(EXIT_SUCCESS == get_mstp_designated_root(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name))
		{
			strncpy(entry->ieee8021MstpDesignatedRoot, result_array[0], MAX_STR_LEN);
			entry->ieee8021MstpDesignatedRoot_len = strlen(entry->ieee8021MstpDesignatedRoot);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpEntry, leaf ieee8021MstpRootPathCost */
		if(EXIT_SUCCESS == get_mstp_root_path_cost(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, tmp_mstp_id))
		{
			entry->ieee8021MstpRootPathCost = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpEntry, leaf ieee8021MstpRootPort */
		if(EXIT_SUCCESS == get_mstp_root_port(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, tmp_mstp_id))
		{
			entry->ieee8021MstpRootPort = strtoul(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpEntry, leaf ieee8021MstpBridgePriority */
		if(EXIT_SUCCESS == get_mstp_bridge_priority(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, tmp_mstp_id))
		{
			entry->ieee8021MstpBridgePriority = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
    }while(0);

    return ret;
}

/* create a new row in the table */
netsnmp_tdata_row* ieee8021MstpTable_createEntry( netsnmp_tdata* table_data
                                                , u_long  ieee8021MstpComponentId
                                                , u_long  ieee8021MstpId
                                                )
{
    struct ieee8021MstpTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(ieee8021MstpTable_entry_t);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;

    snmp_log(LOG_INFO,"ieee8021MstpTable_createEntry - (%ld) - (%ld)\n",
    		ieee8021MstpComponentId, ieee8021MstpId);

    entry->ieee8021MstpComponentId = ieee8021MstpComponentId;
    netsnmp_tdata_row_add_index( row, ASN_UNSIGNED,
                                 &(entry->ieee8021MstpComponentId),
                                 sizeof(entry->ieee8021MstpComponentId));
    entry->ieee8021MstpId = ieee8021MstpId;
    netsnmp_tdata_row_add_index( row, ASN_UNSIGNED,
                                 &(entry->ieee8021MstpId),
                                 sizeof(entry->ieee8021MstpId));
    if (table_data)
        netsnmp_tdata_add_row( table_data, row );
    return row;
}

/* remove a row from the table */
void ieee8021MstpTable_removeEntry( netsnmp_tdata* table_data
		                          , netsnmp_tdata_row *row
								  )
{
    struct ieee8021MstpTable_entry *entry;

    if (!row) return;    /* Nothing to remove */

    snmp_log(LOG_INFO, "ieee8021MstpTable_removeEntry entry.\n");

    entry = (struct ieee8021MstpTable_entry *)row->data;
    SNMP_FREE( entry );   /* XXX - release any other internal resources */

    if (table_data)
        netsnmp_tdata_remove_and_delete_row( table_data, row );
    else
        netsnmp_tdata_delete_row( row );    
}

/* cache handler */
int ieee8021MstpTable_load( netsnmp_cache *cache, void *vmagic )
{
    /* will be used to iterate trough ieee8021MstpTable_head */
    netsnmp_tdata_row *agent_row = NULL;
    /* helper to keep next agent row */
    netsnmp_tdata_row *next_agent_row = NULL;
    /* will be used to check existence of the bridge */
    netsnmp_tdata* table = (netsnmp_tdata *)vmagic;
    ieee8021MstpTable_entry_t *entry;
    char bridges_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
    char mstp_ids[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
    u_long tmp_ieee8021MstpId = 0;
    int i = 0;
    int entry_found = 0;

    //snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__, "is called");
    /* gather fresh system data */
    if(EXIT_FAILURE == get_mstp_bridge_names(bridges_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN))
    {
        snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "get_mstp_bridge_names is failed");
        return 1; //error
    }
	if (EXIT_FAILURE == get_bridge_mstpi(mstp_ids, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridges_name[0]))//only one bridge is supported
	{
		snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Internal error. Bridge mstpi ids are unreachable.");
		return 1; //error
	}
    /* returns the first row in the table */
    agent_row = netsnmp_tdata_row_first (table);
    while(NULL != agent_row)
    {
        entry = (ieee8021MstpTable_entry_t*)agent_row->data;
        if(NULL != entry)
        {
            /* there is no more agent_row, erase it from agent */
            if((!entry->ieee8021MstpComponentId) || (!entry->ieee8021MstpId))
            {
                snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__,
                		"there is no more agent_row, erase it from agent");
                /* returns next row */
                next_agent_row = netsnmp_tdata_row_next (table, agent_row);
                ieee8021MstpTable_removeEntry(table, agent_row);
                agent_row = next_agent_row;
                next_agent_row = NULL;
            }
            /* agent_row exists on system, skip it (leave it on agent), just update objects' value */
            else
            {
                //snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__, "agent_row exist on system, skip it");
                /* refresh data in this existing row on agent */
                ieee8021MstpTable_fillEntry(bridges_name[0], entry->ieee8021MstpComponentId,
                		entry->ieee8021MstpId, (ieee8021MstpTable_entry_t *)agent_row->data);
                /* take next */
                agent_row = netsnmp_tdata_row_next (table, agent_row);
            }
        }
        else
        {
            snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "agent_row->data is NULL");
        }
    }
    /* entry (row) exists on system, but not in cache*/
	while((i < MAX_NUM_OF_INTERFACES) && (0 != strncmp(mstp_ids[i], "", MAX_STR_LEN)))//check all system entries (one by one)
	{
        //snmp_log(LOG_DEBUG, SNMP_MSG_FUN_MSG_AND_TWO_OBJ, __func__, "looking for entry: ", bridges_name[0], mstp_ids[i]);
        /* returns the first row in the table */
        agent_row = netsnmp_tdata_row_first (table);
		tmp_ieee8021MstpId = strtoul(mstp_ids[i], NULL, 10);//for this iteration

        while((NULL != agent_row) && (entry_found == 0))//search all entries in cache (if same entry exists)
        {
            entry = (ieee8021MstpTable_entry_t *)agent_row->data;
			if((bridge_id == entry->ieee8021MstpComponentId) && (tmp_ieee8021MstpId == entry->ieee8021MstpId))
			{
				entry_found = 1;
				break;
			}
			agent_row = netsnmp_tdata_row_next (table, agent_row);
		}
        if(entry_found == 0)
        {
			snmp_log(LOG_DEBUG, SNMP_MSG_FUN_MSG_AND_TWO_OBJ, __func__, "Adding new entry in cache: ", bridges_name[0], mstp_ids[i]);
			agent_row = ieee8021MstpTable_createEntry(table, bridge_id, tmp_ieee8021MstpId);
			ieee8021MstpTable_fillEntry(bridges_name[0], bridge_id, tmp_ieee8021MstpId, agent_row->data);
        }
        entry_found = 0;
        i++;
    }

    return 0; /* OK */
}

void
ieee8021MstpTable_free( netsnmp_cache *cache, void *vmagic ) {
    netsnmp_tdata     *table = (netsnmp_tdata *)vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_row_first(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the ieee8021MstpTable table */
int
ieee8021MstpTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata              *table_data;
    netsnmp_tdata_row          *table_row;
    struct ieee8021MstpTable_entry          *table_entry;
    int                         ret;
    char tmp_ieee8021MstpBridgePriority[MAX_STR_LEN] = {0};
    char tmp_bridge_id[MAX_STR_LEN] = {0};
    char tmp_mstp_id[MAX_STR_LEN] = {0};

    DEBUGMSGTL(("ieee8021MstpTable:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021MstpTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPBRIDGEID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpBridgeId,
                                          table_entry->ieee8021MstpBridgeId_len);
                break;
            case COLUMN_IEEE8021MSTPTIMESINCETOPOLOGYCHANGE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
                                            table_entry->ieee8021MstpTimeSinceTopologyChange);
                break;
            case COLUMN_IEEE8021MSTPTOPOLOGYCHANGES:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER64,
                                            table_entry->ieee8021MstpTopologyChanges);
                break;
#if 0
            case COLUMN_IEEE8021MSTPTOPOLOGYCHANGE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpTopologyChange);
                break;
#endif
            case COLUMN_IEEE8021MSTPDESIGNATEDROOT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpDesignatedRoot,
                                          table_entry->ieee8021MstpDesignatedRoot_len);
                break;
            case COLUMN_IEEE8021MSTPROOTPATHCOST:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpRootPathCost);
                break;
            case COLUMN_IEEE8021MSTPROOTPORT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_UNSIGNED,
                                            table_entry->ieee8021MstpRootPort);
                break;
            case COLUMN_IEEE8021MSTPBRIDGEPRIORITY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpBridgePriority);
                break;
#if 0
            case COLUMN_IEEE8021MSTPVIDS0:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpVids0,
                                          table_entry->ieee8021MstpVids0_len);
                break;
            case COLUMN_IEEE8021MSTPVIDS1:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpVids1,
                                          table_entry->ieee8021MstpVids1_len);
                break;
            case COLUMN_IEEE8021MSTPVIDS2:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpVids2,
                                          table_entry->ieee8021MstpVids2_len);
                break;
            case COLUMN_IEEE8021MSTPVIDS3:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpVids3,
                                          table_entry->ieee8021MstpVids3_len);
                break;
            case COLUMN_IEEE8021MSTPROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpRowStatus);
                break;
#endif
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;
#if 0
            table_entry = (struct ieee8021MstpTable_entry *)
                              netsnmp_tdata_extract_entry(request);
#endif
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPBRIDGEPRIORITY:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
#if 0
            case COLUMN_IEEE8021MSTPROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                         (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
#endif
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
#if 0
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;
            table_row  = netsnmp_tdata_extract_row(  request);
            table_data = netsnmp_tdata_extract_table(request);
            table_info = netsnmp_extract_table_info( request);

            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    table_row = ieee8021MstpTable_createEntry(table_data
                        , *table_info->indexes->val.integer
                        , *table_info->indexes->val.integer
                        );
                    if (table_row) {
                        netsnmp_insert_tdata_row( request, table_row );
                    } else {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
#endif
        break;

    case MODE_SET_FREE:
#if 0
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;
            table_entry = (struct ieee8021MstpTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
            table_info  =     netsnmp_extract_table_info( request);

            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieee8021MstpTable_removeEntry(table_data, table_row );
                    }
                }
            }
        }
#endif
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021MstpTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum)
            {
            case COLUMN_IEEE8021MSTPBRIDGEPRIORITY:
                table_entry->old_ieee8021MstpBridgePriority = table_entry->ieee8021MstpBridgePriority;
                table_entry->ieee8021MstpBridgePriority     = *request->requestvb->val.integer;
                snprintf(tmp_ieee8021MstpBridgePriority, MAX_STR_LEN, "%ld", table_entry->ieee8021MstpBridgePriority);
                snprintf(tmp_bridge_id, MAX_STR_LEN, "%lu", table_entry->ieee8021MstpComponentId);
                snprintf(tmp_mstp_id, MAX_STR_LEN, "%lu", table_entry->ieee8021MstpId);
                if(EXIT_FAILURE == set_mstp_bridge_priority(tmp_bridge_id, tmp_mstp_id, tmp_ieee8021MstpBridgePriority))
				{
					netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
	                snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__, "MODE_SET_ACTION failed");
					return SNMP_ERR_NOERROR;
				}
                break;
            }
        }
#if 0
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_entry = (struct ieee8021MstpTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if (/* XXX */) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
#endif
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021MstpTable_entry *)
                              netsnmp_tdata_extract_entry(request);
#if 0
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
#endif
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPBRIDGEPRIORITY:
                table_entry->ieee8021MstpBridgePriority     = table_entry->old_ieee8021MstpBridgePriority;
                table_entry->old_ieee8021MstpBridgePriority = 0;
                break;
#if 0
            case COLUMN_IEEE8021MSTPROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieee8021MstpTable_removeEntry(table_data, table_row );
                    }
                }
                break;
#endif
            }
        }
        break;

    case MODE_SET_COMMIT:
#if 0
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;
            table_entry = (struct ieee8021MstpTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
            table_info  =     netsnmp_extract_table_info(    request);

            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_ACTIVE:
                    table_entry->ieee8021MstpRowStatus = RS_ACTIVE;
                    break;

                case RS_CREATEANDWAIT:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_NOTINSERVICE:
                    table_entry->ieee8021MstpRowStatus = RS_NOTINSERVICE;
                    break;

                case RS_DESTROY:
                    ieee8021MstpTable_removeEntry(table_data, table_row );
                }
            }
        }
#endif
        break;
    }
    return SNMP_ERR_NOERROR;
}
