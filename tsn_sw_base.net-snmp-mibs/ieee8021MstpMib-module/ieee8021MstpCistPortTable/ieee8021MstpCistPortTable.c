/*
 * TTTech ieee8021MstpMib-mib-module
 * Copyright(c) 2019 TTTech Computertechnik AG.
 *
 * ALL RIGHTS RESERVED.
 * Usage of this software, including source code, netlists, documentation,
 * is subject to restrictions and conditions of the applicable license
 * agreement with TTTech Computertechnik AG or its affiliates.
 *
 * All trademarks used are the property of their respective owners.
 *
 * TTTech Computertechnik AG and its affiliates do not assume any liability
 * arising out of the application or use of any product described or shown
 * herein. TTTech Computertechnik AG and its affiliates reserve the right to
 * make changes, at any time, in order to improve reliability, function or
 * design.
 *
 * Contact Information:
 * support@4me.tttech-dependablenetworks.com
 * TTTech Computertechnik AG, Schoenbrunnerstrasse 7, 1040 Vienna, Austria
 */
/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include "ieee8021MstpCistPortTable.h"
/* libbase includes */
#include "base_prints.h"
#include "base_mstp_linux_tools.h"
#include "base_private_translators.h"

/* defined in the ieee8021MstpCistTable.c */
extern char truth_value_map[2][2][MAX_STR_LEN];

char port_role_map[5][2][MAX_STR_LEN] = {//4 pairs
		{BASE_ROLE_DISABLED_STR,	BASE_ZERO_STR},
		{BASE_ROOT_STR,       		BASE_ONE_STR},
		{BASE_ALTERNATE_STR,  		BASE_TWO_STR},
		{BASE_DESIGNATED_STR, 		BASE_THREE_STR},
		{BASE_BACKUP_STR,     		BASE_FOUR_STR},
};

extern u_long component_id;//component id is 1 - only one bridge is supported

/** Initializes the ieee8021MstpCistPortTable module */
void init_ieee8021MstpCistPortTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_ieee8021MstpCistPortTable();
}

/** Initialize the ieee8021MstpCistPortTable table by defining its contents and how it's structured */
void initialize_table_ieee8021MstpCistPortTable(void)
{
    const oid ieee8021MstpCistPortTable_oid[] = {1,3,111,2,802,1,1,6,1,3};
    const size_t ieee8021MstpCistPortTable_oid_len   = OID_LENGTH(ieee8021MstpCistPortTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_tdata                   *table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache                   *cache;

    DEBUGMSGTL(("ieee8021MstpCistPortTable:init", "initializing table ieee8021MstpCistPortTable\n"));

    reg = netsnmp_create_handler_registration(
              "ieee8021MstpCistPortTable",     ieee8021MstpCistPortTable_handler,
              ieee8021MstpCistPortTable_oid, ieee8021MstpCistPortTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_data = netsnmp_tdata_create_table( "ieee8021MstpCistPortTable", 0 );
    if (NULL == table_data) {
        snmp_log(LOG_ERR,"error creating tdata table for ieee8021MstpCistPortTable\n");
        return;
    }
    cache = netsnmp_cache_create(IEEE8021MSTPCISTPORTTABLE_TIMEOUT,
                                  ieee8021MstpCistPortTable_load, ieee8021MstpCistPortTable_free,
                                  ieee8021MstpCistPortTable_oid, ieee8021MstpCistPortTable_oid_len);

    if (NULL == cache) {
        snmp_log(LOG_ERR,"%s(): error occurred during cache creation\n.", __func__);
    }
    else
    {
        cache->magic = (void *)table_data;
        cache->flags =  NETSNMP_CACHE_DONT_FREE_EXPIRED     | \
                        NETSNMP_CACHE_DONT_AUTO_RELEASE     | \
                        NETSNMP_CACHE_AUTO_RELOAD           | \
                        NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD | \
                        NETSNMP_CACHE_DONT_INVALIDATE_ON_SET ;
    }

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    if (NULL == table_info) {
        snmp_log(LOG_ERR,"error creating table info for ieee8021MstpCistPortTable\n");
        return;
    }
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_UNSIGNED,  /* index: ieee8021MstpCistPortComponentId */
                           ASN_UNSIGNED,  /* index: ieee8021MstpCistPortNum */
                           0);

    table_info->min_column = COLUMN_IEEE8021MSTPCISTPORTUPTIME;
    table_info->max_column = COLUMN_IEEE8021MSTPCISTPORTISL2GP;
    
    netsnmp_tdata_register( reg, table_data, table_info );

    /* Initialise the contents of the table here */
    if(0 != init_ieee8021MstpCistPortTable_with_sys_data(table_data))
    {
        snmp_log(LOG_ERR,"ERROR: ieee8021MstpCistPortTable initialization was unsuccessful.\n");
        free(table_info);
        return;
    }
    else
    {
        snmp_log(LOG_INFO,"INFO: ieee8021MstpCistPortTable initialization was successful.\n");
        netsnmp_cache_timer_start(cache);
    }
}

/* init table */
int init_ieee8021MstpCistPortTable_with_sys_data(netsnmp_tdata *table_data)
{
    netsnmp_tdata_row *row = NULL;
    char ports_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
    char bridges_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
    char tmp_port_id[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
    int i = 0;

    /* gather fresh system data */
    if(EXIT_FAILURE == get_mstp_bridge_names(bridges_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN))
    {
    	snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "get_mstp_bridges_name failed");
        return 1;
    }
    if(EXIT_FAILURE == get_mstp_bridge_port_names(ports_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridges_name[0]))
    {
    	snmp_log(LOG_ERR, "%s(): bridges' names are unreachable.\n", __func__);
        return 1;
    }
    while((i < MAX_NUM_OF_INTERFACES) && (0 != strncmp(ports_name[i], "", MAX_STR_LEN)))
    {
	    if(EXIT_FAILURE == get_mstp_port_id(tmp_port_id, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridges_name[0], ports_name[i]))
	    {
	    	snmp_log(LOG_ERR, SNMP_MSG_FUN_XML_EL_AND_MSG, __func__, "port's id is unreachable for port's name (%s)", ports_name[i]);
	        return 1;/* error */
	    }
		row = ieee8021MstpCistPortTable_createEntry(table_data, component_id, strtoul(tmp_port_id[0], NULL, 10));
		if(NULL != row)
		{
			ieee8021MstpCistPortTable_fillEntry(ports_name[i], bridges_name[0], (ieee8021MstpCistPortTable_entry_t*)row->data);
		}
		else
		{
			snmp_log(LOG_ERR, "%s(): New row is not created.\n", __func__);
			return 1;/* error */
		}
		row = NULL;
    	i++;
    }

    return 0;/* success */
}

/* create a new row in the table */
netsnmp_tdata_row *
ieee8021MstpCistPortTable_createEntry(netsnmp_tdata *table_data
                 , u_long  ieee8021MstpCistPortComponentId
                 , u_long  ieee8021MstpCistPortNum
                ) {
    struct ieee8021MstpCistPortTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct ieee8021MstpCistPortTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;

    snmp_log(LOG_INFO,"ieee8021BridgeBasePortTable_createEntry - (%ld) - (%ld)\n",
    		ieee8021MstpCistPortComponentId, ieee8021MstpCistPortNum);

    entry->ieee8021MstpCistPortComponentId = ieee8021MstpCistPortComponentId;
    netsnmp_tdata_row_add_index( row, ASN_UNSIGNED,
                                 &(entry->ieee8021MstpCistPortComponentId),
                                 sizeof(entry->ieee8021MstpCistPortComponentId));
    entry->ieee8021MstpCistPortNum = ieee8021MstpCistPortNum;
    netsnmp_tdata_row_add_index( row, ASN_UNSIGNED,
                                 &(entry->ieee8021MstpCistPortNum),
                                 sizeof(entry->ieee8021MstpCistPortNum));
    if (table_data)
        netsnmp_tdata_add_row( table_data, row );
    return row;
}

/* fill a new row data in the table */
int ieee8021MstpCistPortTable_fillEntry(char port_name[MAX_STR_LEN],
		char bridge_name[MAX_STR_LEN], ieee8021MstpCistPortTable_entry_t *entry)
{
    char result_array[MAX_NUM_OF_INTERFACES][MAX_STR_LEN];
    int ret = 0;//OK

    snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__, "is called");

    do{
		if (!entry)
		{
			snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "entry == NULL");
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortAdminPathCost */
		if(EXIT_SUCCESS == get_cist_port_admin_path_cost(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			entry->ieee8021MstpCistPortAdminPathCost = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistEntry, leaf ieee8021MstpCistPortDesignatedRoot */
		if(EXIT_SUCCESS == get_cist_port_designated_root(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			strncpy(entry->ieee8021MstpCistPortDesignatedRoot, result_array[0], MAX_STR_LEN);
			entry->ieee8021MstpCistPortDesignatedRoot_len = strlen(entry->ieee8021MstpCistPortDesignatedRoot);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortTopologyChangeAck */
		if(EXIT_SUCCESS == get_cist_port_top_change_ack(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], truth_value_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate topology chanege ack value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortTopologyChangeAck = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortHelloTime */
		if(EXIT_SUCCESS == get_cist_port_hello_time(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			entry->ieee8021MstpCistPortHelloTime = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortAdminEdgePort */
		if(EXIT_SUCCESS == get_cist_port_admin_edge_port(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], truth_value_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate admin edge port value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortAdminEdgePort = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortOperEdgePort */
		if(EXIT_SUCCESS == get_cist_port_oper_edge_port(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], truth_value_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate admin edge port value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortOperEdgePort = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortMacEnabled */
		if(EXIT_SUCCESS == get_cist_port_mac_enabled(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], truth_value_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate mac enable value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortMacEnabled = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortRestrictedRole */
		if(EXIT_SUCCESS == get_cist_port_restricted_role(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], truth_value_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate mac enable value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortRestrictedRole = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortRestrictedTcn */
		if(EXIT_SUCCESS == get_cist_port_restricted_tcn(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], truth_value_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate mac enable value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortRestrictedTcn = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortRole */
		if(EXIT_SUCCESS == get_cist_port_role(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], port_role_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate port role value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortRole = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistPortEntry, leaf ieee8021MstpCistPortDisputed */
		if(EXIT_SUCCESS == get_cist_port_disputed(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			if(EXIT_FAILURE == translate_single_string_using_map(result_array[0], truth_value_map))
			{
				snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "Failed to translate mac enable value!");
				ret = 1;/* error */
				break;
			}
			entry->ieee8021MstpCistPortDisputed = strtol(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistEntry, leaf ieee8021MstpCistPortCistRegionalRootId */
		if(EXIT_SUCCESS == get_cist_port_reg_root_id(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			strncpy(entry->ieee8021MstpCistPortCistRegionalRootId, result_array[0], MAX_STR_LEN);
			entry->ieee8021MstpCistPortCistRegionalRootId_len = strlen(entry->ieee8021MstpCistPortCistRegionalRootId);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
		/* list ieee8021MstpCistEntry, leaf ieee8021MstpCistPortCistPathCost */
		if(EXIT_SUCCESS == get_cist_port_path_cost(result_array, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridge_name, port_name))
		{
			entry->ieee8021MstpCistPortCistPathCost = strtoul(result_array[0], NULL, 10);
		}
		else
		{
			ret = 1;/* error */
			break;
		}
    }while(0);

    return ret;
}

/* remove a row from the table */
void ieee8021MstpCistPortTable_removeEntry(netsnmp_tdata* table_data, netsnmp_tdata_row* row)
{
    struct ieee8021MstpCistPortTable_entry* entry;

    if (!row) return; /* Nothing to remove */

    snmp_log(LOG_INFO, "ieee8021MstpCistPortTable_removeEntry entry.\n");

    entry = (struct ieee8021MstpCistPortTable_entry *)row->data;
    SNMP_FREE( entry );   /* XXX - release any other internal resources */

    if (table_data)
        netsnmp_tdata_remove_and_delete_row( table_data, row );
    else
        netsnmp_tdata_delete_row( row );    
}

/* cache handler */
int ieee8021MstpCistPortTable_load( netsnmp_cache *cache, void *vmagic ) {
    /* will be used to iterate trough ieee8021BridgeBaseTable_head */
        netsnmp_tdata_row* agent_row = NULL;
        /* helper to keep next agent row */
        netsnmp_tdata_row* next_agent_row = NULL;
        /* will be used to check existence of the bridge */
        netsnmp_tdata* table = (netsnmp_tdata *)vmagic;
        ieee8021MstpCistPortTable_entry_t* entry = NULL;
        int port_found = 0;
        char ports_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
        char bridges_name[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
        char tmp_port_id[MAX_NUM_OF_INTERFACES][MAX_STR_LEN] = {0};
        int i = 0;


        /* gather fresh system data */
        if(EXIT_FAILURE == get_mstp_bridge_names(bridges_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN))
        {
        	snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "get_mstp_bridges_name failed");
            return 1;
        }
        if(EXIT_FAILURE == get_mstp_bridge_port_names(ports_name, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridges_name[0]))//only one bridge is supported
        {
            snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "get_mstp_bridge_ports_name is failed");
            return 1;
        }

        /* returns the first row in the table */
        agent_row = netsnmp_tdata_row_first (table);

        while(NULL != agent_row)
        {
            entry = (ieee8021MstpCistPortTable_entry_t *)agent_row->data;

            if(NULL != entry)
            {
                /* there is no more agent_row, erase it from agent */
                if(!entry->ieee8021MstpCistPortComponentId || !entry->ieee8021MstpCistPortNum)
                {
                    /* returns next row */
                    next_agent_row = netsnmp_tdata_row_next (table, agent_row);
                    ieee8021MstpCistPortTable_removeEntry(table, agent_row);
                    agent_row = next_agent_row;
                    next_agent_row = NULL;
                }
                /* agent_row exist on system, skip it (leave it on agent) */
                else
                {
                    i = 0;
                    while((i < MAX_NUM_OF_INTERFACES) && (0 != strncmp(ports_name[i], "", MAX_STR_LEN)))
                    {
                	    if(EXIT_FAILURE == get_mstp_port_id(tmp_port_id, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridges_name[0], ports_name[i]))
                	    {
                	    	snmp_log(LOG_ERR, SNMP_MSG_FUN_XML_EL_AND_MSG, __func__, "port's id is unreachable for port's name (%s)", ports_name[i]);
                	        return 1;/* error */
                	    }
                        if( (component_id == entry->ieee8021MstpCistPortComponentId) &&
                                (strtoul(tmp_port_id[0], NULL, 10) == entry->ieee8021MstpCistPortNum) )
                        {
							/* refresh data in this existing row on agent */
							ieee8021MstpCistPortTable_fillEntry(ports_name[i], bridges_name[0],
									(ieee8021MstpCistPortTable_entry_t *)agent_row->data);
                        }
						i++;
                    }
                    /* take next */
                    agent_row = netsnmp_tdata_row_next (table, agent_row);
                }
            }
            else
            {
                snmp_log(LOG_ERR, SNMP_MSG_FUN_AND_MSG, __func__, "agent_row->data is NULL");
            }
        }

        i = 0;
        while((i < MAX_NUM_OF_INTERFACES) && (0 != strncmp(ports_name[i], "", MAX_STR_LEN)))
        {
 	    if(EXIT_FAILURE == get_mstp_port_id(tmp_port_id, MAX_NUM_OF_INTERFACES, MAX_STR_LEN, bridges_name[0], ports_name[i]))
    	    {
    	    	snmp_log(LOG_ERR, SNMP_MSG_FUN_XML_EL_AND_MSG, __func__, "port's id is unreachable for port's name (%s)", ports_name[i]);
    	        return 1;/* error */
    	    }
            /* returns the first row in the table */
            agent_row = netsnmp_tdata_row_first (table);

            while((NULL != agent_row) && (port_found == 0))
            {
                entry = (ieee8021MstpCistPortTable_entry_t *)agent_row->data;

                if( (component_id == entry->ieee8021MstpCistPortComponentId) &&
                        (strtoul(tmp_port_id[0], NULL, 10) == entry->ieee8021MstpCistPortNum) )
                {
                    port_found = 1;
                }

                agent_row = netsnmp_tdata_row_next (table, agent_row);
            }

            if(port_found == 0)
            {
                agent_row = ieee8021MstpCistPortTable_createEntry(table, component_id, strtoul(tmp_port_id[0], NULL, 10));
                ieee8021MstpCistPortTable_fillEntry(ports_name[i], bridges_name[0], agent_row->data);
            }
            i++;
            port_found = 0;
        }

        return 0; /* OK */
}

void
ieee8021MstpCistPortTable_free( netsnmp_cache *cache, void *vmagic ) {
    netsnmp_tdata     *table = (netsnmp_tdata *)vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_row_first(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the ieee8021MstpCistPortTable table */
int
ieee8021MstpCistPortTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata              *table_data;
    netsnmp_tdata_row          *table_row;
    struct ieee8021MstpCistPortTable_entry          *table_entry;
    int                         ret;
    char tmp_ieee8021MstpCistPortComponentId[MAX_STR_LEN] = {0};
    char tmp_ieee8021MstpCistPortNum[MAX_STR_LEN] = {0};
    char tmp_object_value[MAX_STR_LEN] = {0};

    DEBUGMSGTL(("ieee8021MstpCistPortTable:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021MstpCistPortTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
#if 0
            case COLUMN_IEEE8021MSTPCISTPORTUPTIME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_TIMETICKS,
                                            table_entry->ieee8021MstpCistPortUptime);
                break;
#endif
            case COLUMN_IEEE8021MSTPCISTPORTADMINPATHCOST:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortAdminPathCost);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTDESIGNATEDROOT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpCistPortDesignatedRoot,
                                          table_entry->ieee8021MstpCistPortDesignatedRoot_len);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTTOPOLOGYCHANGEACK:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortTopologyChangeAck);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTHELLOTIME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortHelloTime);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTADMINEDGEPORT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortAdminEdgePort);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTOPEREDGEPORT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortOperEdgePort);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTMACENABLED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortMacEnabled);
                break;
#if 0
            case COLUMN_IEEE8021MSTPCISTPORTMACOPERATIONAL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortMacOperational);
                break;
#endif
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDROLE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortRestrictedRole);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDTCN:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortRestrictedTcn);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTROLE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortRole);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTDISPUTED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortDisputed);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTCISTREGIONALROOTID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpCistPortCistRegionalRootId,
                                          table_entry->ieee8021MstpCistPortCistRegionalRootId_len);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTCISTPATHCOST:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_UNSIGNED,
                                            table_entry->ieee8021MstpCistPortCistPathCost);
                break;
#if 0
            case COLUMN_IEEE8021MSTPCISTPORTPROTOCOLMIGRATION:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortProtocolMigration);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDURX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortEnableBPDURx);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDUTX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortEnableBPDUTx);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTPSEUDOROOTID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021MstpCistPortPseudoRootId,
                                          table_entry->ieee8021MstpCistPortPseudoRootId_len);
                break;
            case COLUMN_IEEE8021MSTPCISTPORTISL2GP:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021MstpCistPortIsL2Gp);
                break;
#endif
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;
#if 0
            table_entry = (struct ieee8021MstpCistPortTable_entry *)
                              netsnmp_tdata_extract_entry(request);
#endif
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPCISTPORTADMINPATHCOST:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTADMINEDGEPORT:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTMACENABLED:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDROLE:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDTCN:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
#if 0
            case COLUMN_IEEE8021MSTPCISTPORTPROTOCOLMIGRATION:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDURX:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDUTX:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTPSEUDOROOTID:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->ieee8021MstpCistPortPseudoRootId));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021MSTPCISTPORTISL2GP:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
#endif
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021MstpCistPortTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            /* take keys */
            snprintf(tmp_ieee8021MstpCistPortComponentId, MAX_STR_LEN, "%lu",
            		table_entry->ieee8021MstpCistPortComponentId);
            snprintf(tmp_ieee8021MstpCistPortNum, MAX_STR_LEN, "%lu",
            		table_entry->ieee8021MstpCistPortNum);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPCISTPORTADMINPATHCOST:
                table_entry->old_ieee8021MstpCistPortAdminPathCost = table_entry->ieee8021MstpCistPortAdminPathCost;
                table_entry->ieee8021MstpCistPortAdminPathCost     = *request->requestvb->val.integer;
	            snprintf(tmp_object_value, MAX_STR_LEN, "%ld", table_entry->ieee8021MstpCistPortAdminPathCost);
				if(EXIT_FAILURE == set_mstp_cist_port_admin_path_cost( tmp_ieee8021MstpCistPortComponentId
						                                             , tmp_ieee8021MstpCistPortNum
																	 , tmp_object_value)
						                                             )
				{
					netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
	                snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__,
	                		"ieee8021MstpCistPortAdminPathCost MODE_SET_ACTION failed");
					return SNMP_ERR_NOERROR;
				}
                break;
            case COLUMN_IEEE8021MSTPCISTPORTADMINEDGEPORT:
                table_entry->old_ieee8021MstpCistPortAdminEdgePort = table_entry->ieee8021MstpCistPortAdminEdgePort;
                table_entry->ieee8021MstpCistPortAdminEdgePort     = *request->requestvb->val.integer;
	            snprintf(tmp_object_value, MAX_STR_LEN, "%ld", table_entry->ieee8021MstpCistPortAdminEdgePort);
				if(EXIT_FAILURE == set_mstp_cist_port_admin_edge_port( tmp_ieee8021MstpCistPortComponentId
						                                             , tmp_ieee8021MstpCistPortNum
																	 , tmp_object_value)
						                                             )
				{
					netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
	                snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__,
	                		"ieee8021MstpCistPortAdminEdgePort MODE_SET_ACTION failed");
					return SNMP_ERR_NOERROR;
				}
                break;
            case COLUMN_IEEE8021MSTPCISTPORTMACENABLED:
                table_entry->old_ieee8021MstpCistPortMacEnabled = table_entry->ieee8021MstpCistPortMacEnabled;
                table_entry->ieee8021MstpCistPortMacEnabled     = *request->requestvb->val.integer;
	            snprintf(tmp_object_value, MAX_STR_LEN, "%ld", table_entry->ieee8021MstpCistPortMacEnabled);
				if(EXIT_FAILURE == set_mstp_cist_port_mac_enabled( tmp_ieee8021MstpCistPortComponentId
						                                         , tmp_ieee8021MstpCistPortNum
															     , tmp_object_value)
						                                         )
				{
					netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
	                snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__,
	                		"ieee8021MstpCistPortMacEnabled MODE_SET_ACTION failed");
					return SNMP_ERR_NOERROR;
				}
                break;
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDROLE:
                table_entry->old_ieee8021MstpCistPortRestrictedRole = table_entry->ieee8021MstpCistPortRestrictedRole;
                table_entry->ieee8021MstpCistPortRestrictedRole     = *request->requestvb->val.integer;
	            snprintf(tmp_object_value, MAX_STR_LEN, "%ld", table_entry->ieee8021MstpCistPortRestrictedRole);
				if(EXIT_FAILURE == set_mstp_cist_port_restricted_role( tmp_ieee8021MstpCistPortComponentId
						                                             , tmp_ieee8021MstpCistPortNum
																	 , tmp_object_value)
						                                             )
				{
					netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
	                snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__,
	                		"ieee8021MstpCistPortRestrictedRole MODE_SET_ACTION failed");
					return SNMP_ERR_NOERROR;
				}
                break;
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDTCN:
                table_entry->old_ieee8021MstpCistPortRestrictedTcn = table_entry->ieee8021MstpCistPortRestrictedTcn;
                table_entry->ieee8021MstpCistPortRestrictedTcn     = *request->requestvb->val.integer;
	            snprintf(tmp_object_value, MAX_STR_LEN, "%ld", table_entry->ieee8021MstpCistPortRestrictedRole);
				if(EXIT_FAILURE == set_mstp_cist_port_restricted_tcn( tmp_ieee8021MstpCistPortComponentId
						                                            , tmp_ieee8021MstpCistPortNum
																	, tmp_object_value)
						                                            )
				{
					netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE);
	                snmp_log(LOG_DEBUG, SNMP_MSG_FUN_AND_MSG, __func__,
	                		"ieee8021MstpCistPortRestrictedRole MODE_SET_ACTION failed");
					return SNMP_ERR_NOERROR;
				}
                break;
#if 0
            case COLUMN_IEEE8021MSTPCISTPORTPROTOCOLMIGRATION:
                table_entry->old_ieee8021MstpCistPortProtocolMigration = table_entry->ieee8021MstpCistPortProtocolMigration;
                table_entry->ieee8021MstpCistPortProtocolMigration     = *request->requestvb->val.integer;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDURX:
                table_entry->old_ieee8021MstpCistPortEnableBPDURx = table_entry->ieee8021MstpCistPortEnableBPDURx;
                table_entry->ieee8021MstpCistPortEnableBPDURx     = *request->requestvb->val.integer;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDUTX:
                table_entry->old_ieee8021MstpCistPortEnableBPDUTx = table_entry->ieee8021MstpCistPortEnableBPDUTx;
                table_entry->ieee8021MstpCistPortEnableBPDUTx     = *request->requestvb->val.integer;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTPSEUDOROOTID:
                memcpy( table_entry->old_ieee8021MstpCistPortPseudoRootId,
                        table_entry->ieee8021MstpCistPortPseudoRootId,
                        sizeof(table_entry->ieee8021MstpCistPortPseudoRootId));
                table_entry->old_ieee8021MstpCistPortPseudoRootId_len =
                        table_entry->ieee8021MstpCistPortPseudoRootId_len;
                memset( table_entry->ieee8021MstpCistPortPseudoRootId, 0,
                        sizeof(table_entry->ieee8021MstpCistPortPseudoRootId));
                memcpy( table_entry->ieee8021MstpCistPortPseudoRootId,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->ieee8021MstpCistPortPseudoRootId_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTISL2GP:
                table_entry->old_ieee8021MstpCistPortIsL2Gp = table_entry->ieee8021MstpCistPortIsL2Gp;
                table_entry->ieee8021MstpCistPortIsL2Gp     = *request->requestvb->val.integer;
                break;
#endif
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ieee8021MstpCistPortTable_entry *)
                              netsnmp_tdata_extract_entry(request);
#if 0
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
#endif
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021MSTPCISTPORTADMINPATHCOST:
                table_entry->ieee8021MstpCistPortAdminPathCost     = table_entry->old_ieee8021MstpCistPortAdminPathCost;
                table_entry->old_ieee8021MstpCistPortAdminPathCost = 0;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTADMINEDGEPORT:
                table_entry->ieee8021MstpCistPortAdminEdgePort     = table_entry->old_ieee8021MstpCistPortAdminEdgePort;
                table_entry->old_ieee8021MstpCistPortAdminEdgePort = 0;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTMACENABLED:
                table_entry->ieee8021MstpCistPortMacEnabled     = table_entry->old_ieee8021MstpCistPortMacEnabled;
                table_entry->old_ieee8021MstpCistPortMacEnabled = 0;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDROLE:
                table_entry->ieee8021MstpCistPortRestrictedRole     = table_entry->old_ieee8021MstpCistPortRestrictedRole;
                table_entry->old_ieee8021MstpCistPortRestrictedRole = 0;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTRESTRICTEDTCN:
                table_entry->ieee8021MstpCistPortRestrictedTcn     = table_entry->old_ieee8021MstpCistPortRestrictedTcn;
                table_entry->old_ieee8021MstpCistPortRestrictedTcn = 0;
                break;
#if 0
            case COLUMN_IEEE8021MSTPCISTPORTPROTOCOLMIGRATION:
                table_entry->ieee8021MstpCistPortProtocolMigration     = table_entry->old_ieee8021MstpCistPortProtocolMigration;
                table_entry->old_ieee8021MstpCistPortProtocolMigration = 0;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDURX:
                table_entry->ieee8021MstpCistPortEnableBPDURx     = table_entry->old_ieee8021MstpCistPortEnableBPDURx;
                table_entry->old_ieee8021MstpCistPortEnableBPDURx = 0;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTENABLEBPDUTX:
                table_entry->ieee8021MstpCistPortEnableBPDUTx     = table_entry->old_ieee8021MstpCistPortEnableBPDUTx;
                table_entry->old_ieee8021MstpCistPortEnableBPDUTx = 0;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTPSEUDOROOTID:
                memcpy( table_entry->ieee8021MstpCistPortPseudoRootId,
                        table_entry->old_ieee8021MstpCistPortPseudoRootId,
                        sizeof(table_entry->ieee8021MstpCistPortPseudoRootId));
                memset( table_entry->old_ieee8021MstpCistPortPseudoRootId, 0,
                        sizeof(table_entry->ieee8021MstpCistPortPseudoRootId));
                table_entry->ieee8021MstpCistPortPseudoRootId_len =
                        table_entry->old_ieee8021MstpCistPortPseudoRootId_len;
                break;
            case COLUMN_IEEE8021MSTPCISTPORTISL2GP:
                table_entry->ieee8021MstpCistPortIsL2Gp     = table_entry->old_ieee8021MstpCistPortIsL2Gp;
                table_entry->old_ieee8021MstpCistPortIsL2Gp = 0;
                break;
#endif
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
